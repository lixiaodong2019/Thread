
线程和进程:
进程是系统进行资源分配和调度的一个独立单位
进程特点：
1.独立性：系统中独立存在的实体，有自己独立的资源，每一个进程都有自己的地址空间。没有进程本身的允许，一个进程不能访问其他进程的地址空间
2.动态性：程序是一个静态的指令集合，进程是一个活动的指令集合，具有自己的生命周期和不同的状态。
3.并发性：多个进程可以在一个处理器上运行，并且不会相互影响

并发性和并行性是不同的概念，并行是指多个指令在多个处理器上同时执行。

线程：
多线程也被称作为轻量级进程，是同一个进程可以并发处理多个任务。
线程是独立运行的，它并不知道进程中是否还有其他线程存在，线程的执行是抢占式的，就是说当前运行的线程在任何时候都可能被挂起，
以便另一个线程运行。
一个线程可以创建和销毁另一个线程。
多线程的优点：
1,进程之间不能共享内存，线程可以
2,创建线程消耗的系统资源比创建进程要低
3,JAVA简化了多线程编程.

(1)线程的创建和启动
1.继承Thread类，重写run方法。
2.创建子类对象
3.调用start方法

Thread.currentThread() :Thread类的静态方法，返回当前正在执行的线程对象
getName():返回调用该方法的线程的名字

实现runnable接口创建线程
1.定义runnable接口的实现类,并重写run方法，该run方法同样是该线程的执行体
2.用该类创建对象，并以此作为Thread的target来创建Thread对象。这个Thread对象才是真正的线程对象。
3.调用线程对象的start方法

多个线程可以共享一个target类的实例变量

Callable和Future
Callable是Runnable的增强版,该接口提供了一个call方法作为线程执行体,但是与run方法不同;
1.该方法有返回值
2.可以声明抛出异常
但是Callable接口并不是Runnable的子接口,所以不能作为target传递给Thread
Future接口提供了一个FutureTask的实现类，该类还实现了Runnable接口。
创建并启动有返回值的线程步骤如下：
1.创建Callable接口的实现类,和实例
2.使用FutureTask来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值
3.使用FutureTask对象作为target
4.调用FutureTask的get方法来获得子线程结束后的返回值

原理:FutureTask里面的Run方法调用了Callable里面的call方法

一般建议用Callable和Runnable接口来创建线程

多线程的生命周期
1.新建 ：new之后，线程就处于创建状态了。
2.就绪：调用start后处于就绪状态
3.运行：
4.阻塞：
阻塞的原因:
(1) 线程调用sleep主动放弃占用的处理资源
(2) 线程调用了一个阻塞IO方法，在该方法返回之前,该线程就会被阻塞。
(3) 线程试图获得一个同步监视器,但是该监视器正在被其他线程所持有。
(4) 线程正在等待某个通知
(5) 线程调用了suspend方法将线程挂起了。
当执行线程被阻塞的时候,其他线程就会获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态。
解除阻塞：
(1) 调用的sleep方法已经过了指定的时间
(2) 阻塞IO方法已经返回
(3) 线程成功地获取到了同步监听器
(4) 线程等待通知时,其他线程发了一个通知
(5) 处于被挂起的线程调用resume方法
调用yield方法可以让线程从运行状态转换到就绪状态
5.消亡
线程死亡：
(1) run或者call方法执行完成,线程正常结束
(2) 线程抛出一个没有捕获的异常或者错误
(3) 调用stop方法
测试线程是否死亡可以用isAlive方法

控制线程
join
thread提供了一个让一个线程等待另一个线程完成的方法 join
在某个线程中调用其他线程的join方法时,调用线程将被阻塞，直到调用join方法的线程执行完毕。
join有三个重载方法
join(long mills):等待被join的时间最长为这么多,过了就不等待了

后台线程(守护线程)
守护线程会在其他线程都死亡后自动死亡

线程睡眠
让当前执行的程序暂停一段时间,并且进入阻塞状态。调用sleep

线程让步：
yield和sleep方法有点相似,可以让当前的线程暂停，但是不会阻塞该线程，会将该线程的状态转成就绪，
然后让线程调度器重新调度一次,真实情况是：该线程调用了yield后,又会被调度出来运行。
实际上,某个线程调用了yield方法后,只有优先级与当前线程相同或者高的才会获得执行的机会。

三个常用的线程优先级
Max
Min
Normal
