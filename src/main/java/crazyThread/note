
线程和进程:
进程是系统进行资源分配和调度的一个独立单位
进程特点：
1.独立性：系统中独立存在的实体，有自己独立的资源，每一个进程都有自己的地址空间。没有进程本身的允许，一个进程不能访问其他进程的地址空间
2.动态性：程序是一个静态的指令集合，进程是一个活动的指令集合，具有自己的生命周期和不同的状态。
3.并发性：多个进程可以在一个处理器上运行，并且不会相互影响

并发性和并行性是不同的概念，并行是指多个指令在多个处理器上同时执行。

线程：
多线程也被称作为轻量级进程，是同一个进程可以并发处理多个任务。
线程是独立运行的，它并不知道进程中是否还有其他线程存在，线程的执行是抢占式的，就是说当前运行的线程在任何时候都可能被挂起，
以便另一个线程运行。
一个线程可以创建和销毁另一个线程。
多线程的优点：
1,进程之间不能共享内存，线程可以
2,创建线程消耗的系统资源比创建进程要低
3,JAVA简化了多线程编程.

(1)线程的创建和启动
1.继承Thread类，重写run方法。
2.创建子类对象
3.调用start方法

Thread.currentThread() :Thread类的静态方法，返回当前正在执行的线程对象
getName():返回调用该方法的线程的名字

实现runnable接口创建线程
1.定义runnable接口的实现类,并重写run方法，该run方法同样是该线程的执行体
2.用该类创建对象，并以此作为Thread的target来创建Thread对象。这个Thread对象才是真正的线程对象。
3.调用线程对象的start方法

多个线程可以共享一个target类的实例变量

Callable和Future
Callable是Runnable的增强版,该接口提供了一个call方法作为线程执行体,但是与run方法不同;
1.该方法有返回值
2.可以声明抛出异常
但是Callable接口并不是Runnable的子接口,所以不能作为target传递给Thread
Future接口提供了一个FutureTask的实现类，该类还实现了Runnable接口。
创建并启动有返回值的线程步骤如下：
1.创建Callable接口的实现类,和实例
2.使用FutureTask来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值
3.使用FutureTask对象作为target
4.调用FutureTask的get方法来获得子线程结束后的返回值

原理:FutureTask里面的Run方法调用了Callable里面的call方法

一般建议用Callable和Runnable接口来创建线程

多线程的生命周期
1.新建 ：new之后，线程就处于创建状态了。
2.就绪：调用start后处于就绪状态
3.运行：
4.阻塞：
阻塞的原因:
(1) 线程调用sleep主动放弃占用的处理资源
(2) 线程调用了一个阻塞IO方法，在该方法返回之前,该线程就会被阻塞。
(3) 线程试图获得一个同步监视器,但是该监视器正在被其他线程所持有。
(4) 线程正在等待某个通知
(5) 线程调用了suspend方法将线程挂起了。
当执行线程被阻塞的时候,其他线程就会获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态。
解除阻塞：
(1) 调用的sleep方法已经过了指定的时间
(2) 阻塞IO方法已经返回
(3) 线程成功地获取到了同步监听器
(4) 线程等待通知时,其他线程发了一个通知
(5) 处于被挂起的线程调用resume方法
调用yield方法可以让线程从运行状态转换到就绪状态
5.消亡
线程死亡：
(1) run或者call方法执行完成,线程正常结束
(2) 线程抛出一个没有捕获的异常或者错误
(3) 调用stop方法
测试线程是否死亡可以用isAlive方法

控制线程
join
thread提供了一个让一个线程等待另一个线程完成的方法 join
在某个线程中调用其他线程的join方法时,调用线程将被阻塞，直到调用join方法的线程执行完毕。
join有三个重载方法
join(long mills):等待被join的时间最长为这么多,过了就不等待了

后台线程(守护线程)
守护线程会在其他线程都死亡后自动死亡

线程睡眠
让当前执行的程序暂停一段时间,并且进入阻塞状态。调用sleep

线程让步：
yield和sleep方法有点相似,可以让当前的线程暂停，但是不会阻塞该线程，会将该线程的状态转成就绪，
然后让线程调度器重新调度一次,真实情况是：该线程调用了yield后,又会被调度出来运行。
实际上,某个线程调用了yield方法后,只有优先级与当前线程相同或者高的才会获得执行的机会。

三个常用的线程优先级
Max
Min
Normal

线程同步
先来一个举例子
同步代码块
synchronized(obj){
//同步代码块
}
obj就是同步监听器
监听器的目的：
阻止两个线程对同一个共享资源进行并发访问,通常推荐被并发访问的资源充当同步监视器(锁)

同步方法
使用synchronized关键词修饰的方法称为同步方法
使用同步方法可以非常方便的实现线程安全的类，线程安全的类特征:
该类的对象可以被多个线程安全的访问
每个线程在调用该对象的任意方法都得到正确的结果
每个线程在调用该对象的任意方法后，该对象仍然保持合理状态
不可变类永远是线程安全类,但是可变对象需要额外的方法来保证线程安丘
例子中的Account对象就是一个可变类,可以被多个线程修改。
所以将该类中对count的访问设置为线程安全的,那么只需要把修改count的方法变成同步方法即可。

释放同步监听器的锁定
任何线程在进入同步代码块或者同步方法时，都必须先获得对同步监听器的锁定。
释放同步监听器的情况
1.当前的同步代码块或者同步方法执行结束时以及遇到break或者return等终止运行时,释放同步监听器
2.在同步代码块/方法 中出现了未处理的异常或者错误,释放同步代码块
3.当前线程执行同步代码块或者方法的时候，程序执行了同步监听器对象的wait方法,则当前线程暂停,并且释放同步监听器。
不会释放的情况
当前线程调用同步代码块时,再调用sleep或者yield以及suspend,resume时不会释放同步监听器

同步锁
一种更加强大的线程同步机制：显式的定义同步锁对象来实现同步,同步锁对象为Lock
Lock提供了比synchronized方法和代码块更加广泛的锁定操作。允许实现更加灵活的结构,支持多个Condition对象
Lock是控制多个线程对共享资源进行访问的工具,锁提供了对共享资源的独占访问,每次只能有一个线程对Lock对象加锁
可重入锁ReentrantLock 是比较常用的,这个锁对象可以显式的加锁，释放锁。格式如下:

1.定义锁对象
2.加锁
3.释放锁｛写在finally代码块中保证释放｝


死锁:两个线程都在互相等待对方释放资源而僵持的状态

线程通信
线程在系统内运行时,线程的调度具有一定的透明性,程序无法准确控制线程的轮换执行。java提供了一些机制来保证线程协调运行。



这三个方法是Object提供的,不属于Thread类,但是这三个方法必须由同步监听器对象来调用:
对于synchronized修饰的同步方法,因为该类的默认实例就是同步监听器,所以可以在同步方法中直接调用这三个方法
对于同步代码块,则必须使用同步监听器来调用
wait:导致当前线程等待,直到其他线程调用notify或者notifyAll来唤醒该线程,带参数的wait方法表示等待多久后自动苏醒。
notify：唤醒在此同步监听器上等待的单个线程,如果所有线程都在等待,则随机选择唤醒其中一个。
notifyAll：唤醒所有的等待中线程。

使用Condition控制线程通信
如果不使用synchronized关键字来保持同步,而是直接使用Lock对象保持同步,这样系统中不存在隐式的同步监听器,
也就不能使用wait,notify等方法。
java提供了一个Condition对象来保证类似的功能
Condition将wait等方法分解成截然不同的对象。Lock代替了同步方法和代码块,Condition代替了同步监视器的功能
Condition实例被绑定在一个Lock对象上,获得Condition的实例,直接调用lock.newCondition。
Condition提供了三个方法:
await:类似于wait方法,导致当前线程等待,直到其他线程调用该condition的signal或者signalAll方法.await方法还有很多变体
signal:唤醒在此Lock上等待的单个线程,类似于notify
signalAll：类似于notifyAll


阻塞队列
BlockingQueue接口,它是Queue的子接口,但是主要用途不是用来作为容器,而是线程同步的工具。
特征:生产者线程试图向BlockingQueue中放入元素时,如果该队列已经满了,则该线程会堵塞,
当消费者线程试图从BlockingQueue中取出元素时,如果队列已经空了,该线程也会堵塞。
原理：
程序的两个线程交替的向BlockingQueue中放入元素和取出元素,可以很好的控制线程的通信。
两个支持阻塞的方法:
put(E e)尝试把E元素放入BlockingQueue中,如果该元素已经满了,则阻塞该线程
take():尝试从BlockingQueue中取出元素,如果该队列的元素已经空,则阻塞该线程
(队列是先进先出,在尾部插入,头部取出)
BlockingQueue 有5个实现类
ArrayBlockingQueue:基于数组实现
LinkedBlockingQueue:基于链表实现的
PriorityBlockingQueue 将队列进行排序,然后再取出元素
SynchronizedBlockingQueue 同步队列,对该队列的存取操作必须同步进行
DelayQueue 一个特殊的阻塞队列,底层基于PriorityBlockingQueue的实现,DelayQueue中的元素都必须实现Delay接口
,根据集合元素的getDelay方法的返回值进行排序