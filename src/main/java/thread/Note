多线程的生命周期
1.新建 ：new之后，线程就处于创建状态了。
2.就绪：调用start后处于就绪状态
3.运行：
4.阻塞：
阻塞的原因:
(1) 线程调用sleep主动放弃占用的处理资源
(2) 线程调用了一个阻塞IO方法，在该方法返回之前,该线程就会被阻塞。
(3) 线程试图获得一个同步监视器,但是该监视器正在被其他线程所持有。
(4) 线程正在等待某个通知
(5) 线程调用了suspend方法将线程挂起了。
当执行线程被阻塞的时候,其他线程就会获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态。
解除阻塞：
(1) 调用的sleep方法已经过了指定的时间
(2) 阻塞IO方法已经返回
(3) 线程成功地获取到了同步监听器
(4) 线程等待通知时,其他线程发了一个通知
(5) 处于被挂起的线程调用resume方法
调用yield方法可以让线程从运行状态转换到就绪状态
5.消亡
线程死亡：
(1) run或者call方法执行完成,线程正常结束
(2) 线程抛出一个没有捕获的异常或者错误
(3) 调用stop方法
测试线程是否死亡可以用isAlive方法

控制线程
join
thread提供了一个让一个线程等待另一个线程完成的方法 join
在某个线程中调用其他线程的join方法时,调用线程将被阻塞，直到调用join方法的线程执行完毕。
join有三个重载方法
join(long mills):等待被join的时间最长为这么多,过了就不等待了

后台线程(守护线程)
守护线程会在其他线程都死亡后自动死亡

线程睡眠
让当前执行的程序暂停一段时间,并且进入阻塞状态。调用sleep

线程让步：
yield和sleep方法有点相似,可以让当前的线程暂停，但是不会阻塞该线程，会将该线程的状态转成就绪，
然后让线程调度器重新调度一次,真实情况是：该线程调用了yield后,又会被调度出来运行。
实际上,某个线程调用了yield方法后,只有优先级与当前线程相同或者高的才会获得执行的机会。

三个常用的线程优先级
Max
Min
Normal

